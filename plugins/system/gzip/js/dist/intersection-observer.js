/* do not edit this file! */
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */
!function(t, e) {
    "use strict";
    // Exits early if all IntersectionObserver and IntersectionObserverEntry
    // features are natively supported.
        if ("IntersectionObserver" in t && "IntersectionObserverEntry" in t && "intersectionRatio" in t.IntersectionObserverEntry.prototype) 
    // Minimal polyfill for Edge 15's lack of `isIntersecting`
    // See: https://github.com/w3c/IntersectionObserver/issues/211
    "isIntersecting" in t.IntersectionObserverEntry.prototype || Object.defineProperty(t.IntersectionObserverEntry.prototype, "isIntersecting", {
        get: function() {
            return this.intersectionRatio > 0;
        }
    }); else {
        /**
 * An IntersectionObserver registry. This registry exists to hold a strong
 * reference to IntersectionObserver instances currently observering a target
 * element. Without this registry, instances without another reference may be
 * garbage collected.
 */
        var n = [];
        /**
 * Creates the global IntersectionObserverEntry constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
 * @param {Object} entry A dictionary of instance properties.
 * @constructor
 */        
        /**
 * The minimum interval within which the document will be checked for
 * intersection changes.
 */
        i.prototype.THROTTLE_TIMEOUT = 100, 
        /**
 * The frequency in which the polyfill polls for intersection changes.
 * this can be updated on a per instance basis and must be set prior to
 * calling `observe` on the first target.
 */
        i.prototype.POLL_INTERVAL = null, 
        /**
 * Use a mutation observer on the root element
 * to detect intersection changes.
 */
        i.prototype.USE_MUTATION_OBSERVER = !0, 
        /**
 * Starts observing a target element for intersection changes based on
 * the thresholds values.
 * @param {Element} target The DOM element to observe.
 */
        i.prototype.observe = function(t) {
            if (!this._observationTargets.some((function(e) {
                return e.element == t;
            }))) {
                if (!t || 1 != t.nodeType) throw new Error("target must be an Element");
                this._registerInstance(), this._observationTargets.push({
                    element: t,
                    entry: null
                }), this._monitorIntersections(), this._checkForIntersections();
            }
        }, 
        /**
 * Stops observing a target element for intersection changes.
 * @param {Element} target The DOM element to observe.
 */
        i.prototype.unobserve = function(t) {
            this._observationTargets = this._observationTargets.filter((function(e) {
                return e.element != t;
            })), this._observationTargets.length || (this._unmonitorIntersections(), this._unregisterInstance());
        }, 
        /**
 * Stops observing all target elements for intersection changes.
 */
        i.prototype.disconnect = function() {
            this._observationTargets = [], this._unmonitorIntersections(), this._unregisterInstance();
        }, 
        /**
 * Returns any queue entries that have not yet been reported to the
 * callback and clears the queue. This can be used in conjunction with the
 * callback to obtain the absolute most up-to-date intersection information.
 * @return {Array} The currently queued entries.
 */
        i.prototype.takeRecords = function() {
            var t = this._queuedEntries.slice();
            return this._queuedEntries = [], t;
        }, 
        /**
 * Accepts the threshold value from the user configuration object and
 * returns a sorted array of unique threshold values. If a value is not
 * between 0 and 1 and error is thrown.
 * @private
 * @param {Array|number=} opt_threshold An optional threshold value or
 *     a list of threshold values, defaulting to [0].
 * @return {Array} A sorted list of unique and valid threshold values.
 */
        i.prototype._initThresholds = function(t) {
            var e = t || [ 0 ];
            return Array.isArray(e) || (e = [ e ]), e.sort().filter((function(t, e, n) {
                if ("number" != typeof t || isNaN(t) || t < 0 || t > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
                return t !== n[e - 1];
            }));
        }, 
        /**
 * Accepts the rootMargin value from the user configuration object
 * and returns an array of the four margin values as an object containing
 * the value and unit properties. If any of the values are not properly
 * formatted or use a unit other than px or %, and error is thrown.
 * @private
 * @param {string=} opt_rootMargin An optional rootMargin value,
 *     defaulting to '0px'.
 * @return {Array<Object>} An array of margin objects with the keys
 *     value and unit.
 */
        i.prototype._parseRootMargin = function(t) {
            var e = (t || "0px").split(/\s+/).map((function(t) {
                var e = /^(-?\d*\.?\d+)(px|%)$/.exec(t);
                if (!e) throw new Error("rootMargin must be specified in pixels or percent");
                return {
                    value: parseFloat(e[1]),
                    unit: e[2]
                };
            }));
            // Handles shorthand.
            return e[1] = e[1] || e[0], e[2] = e[2] || e[0], e[3] = e[3] || e[1], e;
        }, 
        /**
 * Starts polling for intersection changes if the polling is not already
 * happening, and if the page's visibilty state is visible.
 * @private
 */
        i.prototype._monitorIntersections = function() {
            this._monitoringIntersections || (this._monitoringIntersections = !0, 
            // If a poll interval is set, use polling instead of listening to
            // resize and scroll events or DOM mutations.
            this.POLL_INTERVAL ? this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL) : (r(t, "resize", this._checkForIntersections, !0), 
            r(e, "scroll", this._checkForIntersections, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in t && (this._domObserver = new MutationObserver(this._checkForIntersections), 
            this._domObserver.observe(e, {
                attributes: !0,
                childList: !0,
                characterData: !0,
                subtree: !0
            }))));
        }, 
        /**
 * Stops polling for intersection changes.
 * @private
 */
        i.prototype._unmonitorIntersections = function() {
            this._monitoringIntersections && (this._monitoringIntersections = !1, clearInterval(this._monitoringInterval), 
            this._monitoringInterval = null, s(t, "resize", this._checkForIntersections, !0), 
            s(e, "scroll", this._checkForIntersections, !0), this._domObserver && (this._domObserver.disconnect(), 
            this._domObserver = null));
        }, 
        /**
 * Scans each observation target for intersection changes and adds them
 * to the internal entries queue. If new entries are found, it
 * schedules the callback to be invoked.
 * @private
 */
        i.prototype._checkForIntersections = function() {
            var e = this._rootIsInDom(), n = e ? this._getRootRect() : {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            };
            this._observationTargets.forEach((function(i) {
                var r = i.element, s = h(r), c = this._rootContainsTarget(r), a = i.entry, u = e && c && this._computeTargetAndRootIntersection(r, n), l = i.entry = new o({
                    time: t.performance && performance.now && performance.now(),
                    target: r,
                    boundingClientRect: s,
                    rootBounds: n,
                    intersectionRect: u
                });
                a ? e && c ? 
                // If the new entry intersection ratio has crossed any of the
                // thresholds, add a new entry.
                this._hasCrossedThreshold(a, l) && this._queuedEntries.push(l) : 
                // If the root is not in the DOM or target is not contained within
                // root but the previous entry for this target had an intersection,
                // add a new record indicating removal.
                a && a.isIntersecting && this._queuedEntries.push(l) : this._queuedEntries.push(l);
            }), this), this._queuedEntries.length && this._callback(this.takeRecords(), this);
        }, 
        /**
 * Accepts a target and root rect computes the intersection between then
 * following the algorithm in the spec.
 * TODO(philipwalton): at this time clip-path is not considered.
 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
 * @param {Element} target The target DOM element
 * @param {Object} rootRect The bounding rect of the root after being
 *     expanded by the rootMargin value.
 * @return {?Object} The final intersection rect object or undefined if no
 *     intersection is found.
 * @private
 */
        i.prototype._computeTargetAndRootIntersection = function(n, o) {
            // If the element isn't displayed, an intersection can't happen.
            if ("none" != t.getComputedStyle(n).display) {
                for (var i, r, s, c, u, l, p, d, f = h(n), g = a(n), _ = !1; !_; ) {
                    var v = null, m = 1 == g.nodeType ? t.getComputedStyle(g) : {};
                    // If the parent isn't displayed, an intersection can't happen.
                    if ("none" == m.display) return;
                    // If either of the above conditionals set a new parentRect,
                    // calculate new intersection data.
                    if (g == this.root || g == e ? (_ = !0, v = o) : 
                    // If the element has a non-visible overflow, and it's not the <body>
                    // or <html> element, update the intersection rect.
                    // Note: <body> and <html> cannot be clipped to a rect that's not also
                    // the document rect, so no need to compute a new intersection.
                    g != e.body && g != e.documentElement && "visible" != m.overflow && (v = h(g)), 
                    v && (i = v, r = f, s = void 0, c = void 0, u = void 0, l = void 0, p = void 0, 
                    d = void 0, s = Math.max(i.top, r.top), c = Math.min(i.bottom, r.bottom), u = Math.max(i.left, r.left), 
                    l = Math.min(i.right, r.right), d = c - s, !(f = (p = l - u) >= 0 && d >= 0 && {
                        top: s,
                        bottom: c,
                        left: u,
                        right: l,
                        width: p,
                        height: d
                    }))) break;
                    g = a(g);
                }
                return f;
            }
        }, 
        /**
 * Returns the root rect after being expanded by the rootMargin value.
 * @return {Object} The expanded root rect.
 * @private
 */
        i.prototype._getRootRect = function() {
            var t;
            if (this.root) t = h(this.root); else {
                // Use <html>/<body> instead of window since scroll bars affect size.
                var n = e.documentElement, o = e.body;
                t = {
                    top: 0,
                    left: 0,
                    right: n.clientWidth || o.clientWidth,
                    width: n.clientWidth || o.clientWidth,
                    bottom: n.clientHeight || o.clientHeight,
                    height: n.clientHeight || o.clientHeight
                };
            }
            return this._expandRectByRootMargin(t);
        }, 
        /**
 * Accepts a rect and expands it by the rootMargin value.
 * @param {Object} rect The rect object to expand.
 * @return {Object} The expanded rect.
 * @private
 */
        i.prototype._expandRectByRootMargin = function(t) {
            var e = this._rootMarginValues.map((function(e, n) {
                return "px" == e.unit ? e.value : e.value * (n % 2 ? t.width : t.height) / 100;
            })), n = {
                top: t.top - e[0],
                right: t.right + e[1],
                bottom: t.bottom + e[2],
                left: t.left - e[3]
            };
            return n.width = n.right - n.left, n.height = n.bottom - n.top, n;
        }, 
        /**
 * Accepts an old and new entry and returns true if at least one of the
 * threshold values has been crossed.
 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
 *    particular target element or null if no previous entry exists.
 * @param {IntersectionObserverEntry} newEntry The current entry for a
 *    particular target element.
 * @return {boolean} Returns true if a any threshold has been crossed.
 * @private
 */
        i.prototype._hasCrossedThreshold = function(t, e) {
            // To make comparing easier, an entry that has a ratio of 0
            // but does not actually intersect is given a value of -1
            var n = t && t.isIntersecting ? t.intersectionRatio || 0 : -1, o = e.isIntersecting ? e.intersectionRatio || 0 : -1;
            // Ignore unchanged ratios
            if (n !== o) for (var i = 0; i < this.thresholds.length; i++) {
                var r = this.thresholds[i];
                // Return true if an entry matches a threshold or if the new ratio
                // and the old ratio are on the opposite sides of a threshold.
                                if (r == n || r == o || r < n != r < o) return !0;
            }
        }, 
        /**
 * Returns whether or not the root element is an element and is in the DOM.
 * @return {boolean} True if the root element is an element and is in the DOM.
 * @private
 */
        i.prototype._rootIsInDom = function() {
            return !this.root || c(e, this.root);
        }, 
        /**
 * Returns whether or not the target element is a child of root.
 * @param {Element} target The target element to check.
 * @return {boolean} True if the target element is a child of root.
 * @private
 */
        i.prototype._rootContainsTarget = function(t) {
            return c(this.root || e, t);
        }, 
        /**
 * Adds the instance to the global IntersectionObserver registry if it isn't
 * already present.
 * @private
 */
        i.prototype._registerInstance = function() {
            n.indexOf(this) < 0 && n.push(this);
        }, 
        /**
 * Removes the instance from the global IntersectionObserver registry.
 * @private
 */
        i.prototype._unregisterInstance = function() {
            var t = n.indexOf(this);
            -1 != t && n.splice(t, 1);
        }, 
        // Exposes the constructors globally.
        t.IntersectionObserver = i, t.IntersectionObserverEntry = o;
    }
    function o(t) {
        this.time = t.time, this.target = t.target, this.rootBounds = t.rootBounds, this.boundingClientRect = t.boundingClientRect, 
        this.intersectionRect = t.intersectionRect || {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        }, this.isIntersecting = !!t.intersectionRect;
        // Calculates the intersection ratio.
        var e = this.boundingClientRect, n = e.width * e.height, o = this.intersectionRect, i = o.width * o.height;
        // Sets intersection ratio.
        this.intersectionRatio = n ? i / n : this.isIntersecting ? 1 : 0;
    }
    /**
 * Creates the global IntersectionObserver constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
 * @param {Function} callback The function to be invoked after intersection
 *     changes have queued. The function is not invoked if the queue has
 *     been emptied by calling the `takeRecords` method.
 * @param {Object=} opt_options Optional configuration options.
 * @constructor
 */    function i(t, e) {
        var n, o, i, r = e || {};
        if ("function" != typeof t) throw new Error("callback must be a function");
        if (r.root && 1 != r.root.nodeType) throw new Error("root must be an Element");
        // Binds and throttles `this._checkForIntersections`.
                this._checkForIntersections = (n = this._checkForIntersections.bind(this), 
        o = this.THROTTLE_TIMEOUT, i = null, function() {
            i || (i = setTimeout((function() {
                n(), i = null;
            }), o));
        }), 
        // Private properties.
        this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(r.rootMargin), 
        // Public properties.
        this.thresholds = this._initThresholds(r.threshold), this.root = r.root || null, 
        this.rootMargin = this._rootMarginValues.map((function(t) {
            return t.value + t.unit;
        })).join(" ");
    }
    /**
 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
 * @param {Node} node The DOM node to add the event handler to.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to add.
 * @param {boolean} opt_useCapture Optionally adds the even to the capture
 *     phase. Note: this only works in modern browsers.
 */
    function r(t, e, n, o) {
        "function" == typeof t.addEventListener ? t.addEventListener(e, n, o || !1) : "function" == typeof t.attachEvent && t.attachEvent("on" + e, n);
    }
    /**
 * Removes a previously added event handler from a DOM node.
 * @param {Node} node The DOM node to remove the event handler from.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to remove.
 * @param {boolean} opt_useCapture If the event handler was added with this
 *     flag set to true, it should be set to true here in order to remove it.
 */    function s(t, e, n, o) {
        "function" == typeof t.removeEventListener ? t.removeEventListener(e, n, o || !1) : "function" == typeof t.detatchEvent && t.detatchEvent("on" + e, n);
    }
    /**
 * Returns the intersection between two rect objects.
 * @param {Object} rect1 The first rect.
 * @param {Object} rect2 The second rect.
 * @return {?Object} The intersection rect or undefined if no intersection
 *     is found.
 */    
    /**
 * Shims the native getBoundingClientRect for compatibility with older IE.
 * @param {Element} el The element whose bounding rect to get.
 * @return {Object} The (possibly shimmed) rect of the element.
 */
    function h(t) {
        var e;
        try {
            e = t.getBoundingClientRect();
        } catch (t) {
            // Ignore Windows 7 IE11 "Unspecified error"
            // https://github.com/w3c/IntersectionObserver/pull/205
        }
        return e ? (
        // Older IE
        e.width && e.height || (e = {
            top: e.top,
            right: e.right,
            bottom: e.bottom,
            left: e.left,
            width: e.right - e.left,
            height: e.bottom - e.top
        }), e) : {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        };
    }
    /**
 * Returns an empty rect object. An empty rect is returned when an element
 * is not in the DOM.
 * @return {Object} The empty rect.
 */    
    /**
 * Checks to see if a parent element contains a child elemnt (including inside
 * shadow DOM).
 * @param {Node} parent The parent element.
 * @param {Node} child The child element.
 * @return {boolean} True if the parent node contains the child node.
 */
    function c(t, e) {
        for (var n = e; n; ) {
            if (n == t) return !0;
            n = a(n);
        }
        return !1;
    }
    /**
 * Gets the parent node of an element or its host element if the parent node
 * is a shadow root.
 * @param {Node} node The node whose parent to get.
 * @return {Node|null} The parent node or null if no parent exists.
 */    function a(t) {
        var e = t.parentNode;
        return e && 11 == e.nodeType && e.host ? e.host : e;
    }
}(window, document);